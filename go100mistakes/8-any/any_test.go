// Используя any, мы теряем некоторые преимущества Go как языка со статической
// типизацией. Следует избегать типа any и делать сигнатуры максимально явными.
// Что касается нашего примера, это может означать дублирование методов Get
// и Set для каждого типа
// func (s *Store) GetContract(id string) (Contract, error) {
// // ...
// }
// func (s *Store) GetCustomer(id string) (Customer, error) {
// // ...
// }
// вместо
// func (s *Store) Get(id string) (any, error) {
// // ...
// }
//
// В каких случаи any полезен?
// Первый пример находится в пакете encoding/json. Маrshal.
// Другой пример можно найти в пакете database/sql. Если запрос параметризован
// (например, SELECT * FROM FOO WHERE id = ?), параметры могут быть любыми.
//
// Таким образом, any может быть полезен, если есть реальная необходимость
// принять или вернуть любой возможный тип (например, когда дело доходит до
// маршалинга или форматирования). В общем, мы должны любой ценой избегать
// чрезмерного обобщения своего кода. Возможно, иногда небольшое дублирование кода будет приветствоваться,
// если это улучшает другие аспекты, например выразительность.
package __any

import "testing"

func TestAny(t *testing.T) {
	var i any
	i = 42       // Тип int
	i = "foo"    // ип string
	i = struct { // Структура
		s string
	}{
		s: "bar",
	}
	i = f // Функция
	_ = i // Присвоение значения пустому идентификатору, чтобы пример мог скомпилироваться
}
func f() {}
